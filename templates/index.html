<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Voice Chat</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #cccccc;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simple Voice Chat</h1>
        
        <div>
            <h3>Room</h3>
            <div class="controls">
                <input type="text" id="roomId" placeholder="Enter room ID">
                <button id="joinBtn">Join Room</button>
                <button id="leaveBtn" disabled>Leave Room</button>
            </div>
        </div>
        
        <div>
            <h3>Audio Controls</h3>
            <div class="controls">
                <button id="startAudioBtn" disabled>Start Audio</button>
                <button id="stopAudioBtn" disabled>Stop Audio</button>
            </div>
        </div>
        
        <div id="status" class="status disconnected">
            Disconnected
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        // DOM elements
        const roomIdInput = document.getElementById('roomId');
        const joinBtn = document.getElementById('joinBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const startAudioBtn = document.getElementById('startAudioBtn');
        const stopAudioBtn = document.getElementById('stopAudioBtn');
        const statusDiv = document.getElementById('status');
        
        // WebRTC variables
        let socket;
        let localStream;
        let peerConnection;
        let currentRoom;
        let isInitiator = false;
        let isConnecting = false;
        
        // Configuration for WebRTC
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };
        
        // Setup local media stream
        async function setupLocalStream() {
            if (!localStream) {
                console.log('Setting up local stream');
                try {
                    // Use more specific audio constraints
                    const constraints = {
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        },
                        video: false
                    };
                    
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // Check if we got audio tracks
                    const audioTracks = localStream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        console.log('Got audio track:', audioTracks[0].label);
                        // Set track to enabled
                        audioTracks[0].enabled = true;
                    } else {
                        console.error('No audio tracks found in stream');
                        alert('No audio track found. Please check your microphone settings.');
                    }
                    
                    // Add a local audio element to monitor your own voice (optional)
                    const localAudio = document.createElement('audio');
                    localAudio.id = 'localAudio';
                    localAudio.muted = true; // Mute to prevent feedback
                    localAudio.srcObject = localStream;
                    localAudio.style.display = 'none';
                    document.body.appendChild(localAudio);
                    localAudio.play().catch(e => console.error('Could not play local audio', e));
                    
                    console.log('Local stream setup complete');
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    alert('Error accessing microphone. Please check permissions: ' + error.message);
                    throw error;
                }
            } else {
                console.log('Local stream already exists');
            }
            return localStream;
        }
                
        function createPeerConnection() {
            console.log('Creating peer connection');
            if (peerConnection) {
                console.log('Peer connection already exists, cleaning up old one');
                peerConnection.close();
            }
            
            peerConnection = new RTCPeerConnection(iceServers);
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Generated ICE candidate');
                    socket.emit('ice_candidate', {
                        candidate: event.candidate,
                        room: currentRoom
                    });
                }
            };
            
            peerConnection.onconnectionstatechange = (event) => {
                console.log('Connection state change:', peerConnection.connectionState);
            };

            peerConnection.onsignalingstatechange = (event) => {
                console.log('Signaling state change:', peerConnection.signalingState);
            };

            peerConnection.onicegatheringstatechange = (event) => {
                console.log('ICE gathering state change:', peerConnection.iceGatheringState);
            };
            
            peerConnection.oniceconnectionstatechange = (event) => {
                console.log('ICE connection state change:', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'disconnected' || 
                    peerConnection.iceConnectionState === 'failed') {
                    console.log('ICE connection failed or disconnected');
                    resetConnection();
                }
            };
            
            peerConnection.ontrack = (event) => {
                console.log('Received remote track', event.streams[0]);
                
                // Create a new audio element 
                const remoteAudio = document.createElement('audio');
                remoteAudio.id = 'remoteAudio';
                remoteAudio.srcObject = event.streams[0];
                remoteAudio.autoplay = true;
                remoteAudio.controls = true;
                
                // Set volume to maximum
                remoteAudio.volume = 1.0;
                
                // Try to play it immediately
                remoteAudio.play().then(() => {
                    console.log('Audio playback started successfully');
                }).catch(err => {
                    console.error('Failed to play remote audio:', err);
                    // Try to play it again after a user interaction
                    document.body.addEventListener('click', () => {
                        remoteAudio.play().catch(e => console.error('Still cannot play audio', e));
                    }, { once: true });
                });
                
                // Add visual indicator and controls
                const audioContainer = document.createElement('div');
                audioContainer.id = 'audioContainer';
                audioContainer.style.marginTop = '20px';
                audioContainer.style.padding = '10px';
                audioContainer.style.backgroundColor = '#d4edda';
                audioContainer.style.borderRadius = '4px';
                
                const audioLabel = document.createElement('div');
                audioLabel.textContent = 'Remote Audio Stream:';
                audioLabel.style.marginBottom = '10px';
                
                const volumeControl = document.createElement('div');
                volumeControl.innerHTML = '<label>Volume: <input type="range" min="0" max="1" step="0.1" value="1" id="volumeControl"></label>';
                
                audioContainer.appendChild(audioLabel);
                audioContainer.appendChild(remoteAudio);
                audioContainer.appendChild(volumeControl);
                
                // Add volume control functionality
                const volumeSlider = volumeControl.querySelector('#volumeControl');
                volumeSlider.addEventListener('input', () => {
                    remoteAudio.volume = volumeSlider.value;
                });
                
                // Remove any existing audio container
                const existingContainer = document.getElementById('audioContainer');
                if (existingContainer) {
                    existingContainer.remove();
                }
                
                document.querySelector('.container').appendChild(audioContainer);
                
                // Add audio visualization if browser supports it
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const source = audioContext.createMediaStreamSource(event.streams[0]);
                    source.connect(analyser);
                    
                    console.log('Audio visualization created');
                    
                    // Log audio levels periodically to debug
                    setInterval(() => {
                        const dataArray = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        console.log('Remote audio level:', average);
                    }, 2000);
                } catch (e) {
                    console.error('Could not create audio visualization:', e);
                }
                
                statusDiv.textContent = 'Connected! Voice chat active.';
                statusDiv.className = 'status connected';
            };
            
            // Add local stream tracks to peer connection
            if (localStream) {
                console.log('Adding local tracks to peer connection');
                localStream.getTracks().forEach(track => {
                    console.log('Adding track to connection:', track.kind, track.id);
                    peerConnection.addTrack(track, localStream);
                });
            } else {
                console.warn('No local stream available to add tracks');
            }
            
            return peerConnection;
        }
        // Reset WebRTC connection
        function resetConnection() {
            console.log('Resetting connection');
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            isConnecting = false;
            
            // Remove any existing audio container
            const audioContainer = document.getElementById('audioContainer');
            if (audioContainer) {
                audioContainer.remove();
            }
            
            statusDiv.textContent = 'Connection reset. Try again.';
            statusDiv.className = 'status disconnected';
            
            // If still in a room, enable the start button
            if (currentRoom) {
                startAudioBtn.disabled = false;
            }
        }

        // Initialize socket connection
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', () => {
                console.log('Connected to server');
            });
            
            socket.on('user_joined', (data) => {
                console.log(data.message);
                statusDiv.textContent = 'Another user joined. You can start audio.';
                startAudioBtn.disabled = false;
                
                // First user in the room becomes the initiator
                if (data.count === 1) {
                    isInitiator = true;
                    console.log('You are the initiator');
                } else {
                    isInitiator = false;
                    console.log('You are the receiver');
                }
            });
            
            socket.on('user_left', (data) => {
                console.log(data.message);
                statusDiv.textContent = 'Other user left the room.';
                startAudioBtn.disabled = true;
                stopAudio();
            });
            
            socket.on('offer', async (data) => {
                try {
                    console.log('Received offer');
                    if (isConnecting) {
                        console.log('Already in connecting process, ignoring offer');
                        return;
                    }
                    
                    isConnecting = true;
                    
                    if (!peerConnection) {
                        await setupLocalStream();
                        createPeerConnection();
                    }
                    
                    const remoteDesc = new RTCSessionDescription(data.offer);
                    console.log('Setting remote description (offer)');
                    
                    await peerConnection.setRemoteDescription(remoteDesc);
                    console.log('Remote description set successfully');
                    
                    console.log('Creating answer');
                    const answer = await peerConnection.createAnswer();
                    
                    console.log('Setting local description (answer)');
                    await peerConnection.setLocalDescription(answer);
                    
                    socket.emit('answer', {
                        answer: answer,
                        room: currentRoom
                    });
                    
                    isConnecting = false;
                } catch (error) {
                    console.error('Error handling offer:', error);
                    isConnecting = false;
                    resetConnection();
                }
            });
            
            socket.on('answer', async (data) => {
                try {
                    console.log('Received answer');
                    if (!peerConnection || peerConnection.signalingState === 'stable') {
                        console.log('No pending offer, ignoring answer');
                        return;
                    }
                    
                    console.log('Setting remote description (answer)');
                    const remoteDesc = new RTCSessionDescription(data.answer);
                    await peerConnection.setRemoteDescription(remoteDesc);
                    console.log('Remote description set successfully');
                } catch (error) {
                    console.error('Error handling answer:', error);
                    resetConnection();
                }
            });
            
            socket.on('ice_candidate', async (data) => {
                try {
                    console.log('Received ICE candidate');
                    if (!peerConnection) {
                        console.log('No peer connection, caching candidate');
                        return;
                    }
                    
                    if (data.candidate) {
                        console.log('Adding ICE candidate');
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                        console.log('ICE candidate added successfully');
                    }
                } catch (error) {
                    console.error('Error adding ice candidate:', error);
                }
            });
        }
        
        async function startAudio() {
            try {
                if (isConnecting) {
                    console.log('Already in connecting process');
                    return;
                }
                
                isConnecting = true;
                startAudioBtn.disabled = true;
                
                console.log('Starting audio');
                await setupLocalStream();
                createPeerConnection();
                
                // Only create an offer if we're the initiator
                if (isInitiator) {
                    console.log('Creating offer as initiator');
                    const offerOptions = {
                        offerToReceiveAudio: true,
                        voiceActivityDetection: false
                    };
                    
                    const offer = await peerConnection.createOffer(offerOptions);
                    
                    console.log('Setting local description (offer)');
                    await peerConnection.setLocalDescription(offer);
                    
                    socket.emit('offer', {
                        offer: offer,
                        room: currentRoom
                    });
                } else {
                    console.log('Not initiator, waiting for offer');
                }
                
                stopAudioBtn.disabled = false;
                isConnecting = false;
            } catch (error) {
                console.error('Error starting audio:', error);
                alert('Error starting audio: ' + error.message);
                isConnecting = false;
                resetConnection();
            }
        }

        // Stop audio streaming
        function stopAudio() {
            console.log('Stopping audio');
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    console.log('Stopping track:', track);
                    track.stop();
                });
                localStream = null;
            }
            
            if (peerConnection) {
                console.log('Closing peer connection');
                peerConnection.close();
                peerConnection = null;
            }
            
            // Remove any existing audio container
            const audioContainer = document.getElementById('audioContainer');
            if (audioContainer) {
                audioContainer.remove();
            }
            
            startAudioBtn.disabled = false;
            stopAudioBtn.disabled = true;
            statusDiv.textContent = 'Audio stopped.';
            statusDiv.className = 'status disconnected';
        }
        
        // Join a room
        function joinRoom() {
            const roomId = roomIdInput.value.trim();
            if (!roomId) {
                alert('Please enter a room ID');
                return;
            }
            
            currentRoom = roomId;
            socket.emit('join', { room: roomId });
            
            joinBtn.disabled = true;
            leaveBtn.disabled = false;
            roomIdInput.disabled = true;
            
            statusDiv.textContent = 'Joined room ' + roomId + '. Waiting for another user...';
        }
        
        // Leave a room
        function leaveRoom() {
            socket.emit('leave', { room: currentRoom });
            
            stopAudio();
            
            joinBtn.disabled = false;
            leaveBtn.disabled = true;
            startAudioBtn.disabled = true;
            stopAudioBtn.disabled = true;
            roomIdInput.disabled = false;
            
            statusDiv.textContent = 'Disconnected';
            statusDiv.className = 'status disconnected';
        }
        
        // Event listeners
        joinBtn.addEventListener('click', joinRoom);
        leaveBtn.addEventListener('click', leaveRoom);
        startAudioBtn.addEventListener('click', startAudio);
        stopAudioBtn.addEventListener('click', stopAudio);
        
        // Initialize connection when page loads
        initializeSocket();
        
        // Add debug logging for audio state
        navigator.mediaDevices.ondevicechange = function(event) {
            console.log('Media devices changed:', event);
        };
        
        // Add console logger for debugging connection issues
        setInterval(() => {
            if (peerConnection) {
                peerConnection.getStats().then(stats => {
                    let audioFound = false;
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                            console.log('Receiving audio packets:', report.packetsReceived);
                            audioFound = true;
                        }
                    });
                    if (!audioFound && localStream) {
                        console.log('WARNING: No inbound audio packets detected');
                    }
                });
            }
        }, 5000);

        function debugAudioConnection() {
            console.log('---- DEBUG AUDIO CONNECTION ----');
            
            // Check if microphone access is working
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                console.log('Local audio tracks:', audioTracks.length);
                audioTracks.forEach(track => {
                    console.log('Track:', track.label, 'Enabled:', track.enabled, 'Muted:', track.muted);
                    
                    // Get audio levels if possible
                    if (typeof track.getSettings === 'function') {
                        const settings = track.getSettings();
                        console.log('Track settings:', settings);
                    }
                });
            } else {
                console.log('No local stream available');
            }
            
            // Check peer connection state
            if (peerConnection) {
                console.log('PeerConnection state:');
                console.log('- signaling:', peerConnection.signalingState);
                console.log('- ice connection:', peerConnection.iceConnectionState);
                console.log('- ice gathering:', peerConnection.iceGatheringState);
                console.log('- connection:', peerConnection.connectionState);
                
                // Check if we have senders and receivers
                const senders = peerConnection.getSenders();
                console.log('Senders:', senders.length);
                
                const receivers = peerConnection.getReceivers();
                console.log('Receivers:', receivers.length);
                
                // Get stats to see if data is flowing
                peerConnection.getStats().then(stats => {
                    let inboundFound = false;
                    let outboundFound = false;
                    
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                            inboundFound = true;
                            console.log('Receiving audio:');
                            console.log('- packets received:', report.packetsReceived);
                            console.log('- bytes received:', report.bytesReceived);
                            console.log('- packets lost:', report.packetsLost);
                            console.log('- jitter:', report.jitter);
                        }
                        
                        if (report.type === 'outbound-rtp' && report.kind === 'audio') {
                            outboundFound = true;
                            console.log('Sending audio:');
                            console.log('- packets sent:', report.packetsSent);
                            console.log('- bytes sent:', report.bytesSent);
                        }
                    });
                    
                    if (!inboundFound) {
                        console.log('No inbound audio stream detected!');
                    }
                    
                    if (!outboundFound) {
                        console.log('No outbound audio stream detected!');
                    }
                });
            } else {
                console.log('No peer connection available');
            }
            
            // Check audio elements
            const localAudio = document.getElementById('localAudio');
            const remoteAudio = document.getElementById('remoteAudio');
            
            console.log('Local audio element:', localAudio ? 'exists' : 'missing');
            console.log('Remote audio element:', remoteAudio ? 'exists' : 'missing');
            
            if (remoteAudio) {
                console.log('Remote audio properties:');
                console.log('- paused:', remoteAudio.paused);
                console.log('- muted:', remoteAudio.muted);
                console.log('- volume:', remoteAudio.volume);
                console.log('- has audio tracks:', remoteAudio.srcObject && 
                        remoteAudio.srcObject.getAudioTracks().length > 0);
            }
        }
        // Add a button to run the debug function
        const debugButton = document.createElement('button');
        debugButton.textContent = 'Debug Audio';
        debugButton.style.marginTop = '10px';
        debugButton.style.backgroundColor = '#6c757d';
        debugButton.style.color = 'white';
        debugButton.style.border = 'none';
        debugButton.style.borderRadius = '4px';
        debugButton.style.padding = '10px 15px';
        debugButton.style.cursor = 'pointer';
        debugButton.onclick = debugAudioConnection;

        // Add the button to the page
        document.querySelector('.controls').appendChild(debugButton);
    </script>
</body>
</html>