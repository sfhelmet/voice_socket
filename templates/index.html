<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloud Walky - Secure Voice Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="container">
        <div class="auth-container" id="authContainer">
            <h2>Cloud Walky</h2>
            <div class="button-group">
                <button id="createRoomBtn">Create New Room</button>
                <button id="joinRoomBtn">Join Existing Room</button>
            </div>
            <div id="createRoomForm" style="display: none;">
                <h3>Create Room</h3>
                <div class="form-group">
                    <input type="text" id="newRoomId" placeholder="Room ID">
                    <input type="password" id="newRoomPassword" placeholder="Password">
                </div>
                <button id="createRoomSubmit">Create Room</button>
            </div>
            <div id="joinRoomForm" style="display: none;">
                <h3>Join Room</h3>
                <div class="form-group">
                    <input type="text" id="roomId" placeholder="Room ID">
                    <input type="password" id="roomPassword" placeholder="Password">
                </div>
                <button id="joinRoomSubmit">Join Room</button>
            </div>
            <div id="authError" class="error-message"></div>
        </div>

        <div class="chat-container" id="chatContainer">
            <h1>Cloud Walky</h1>
            <div class="room-info">
                <div id="participantCount">1 person in room</div>
                <button id="leaveRoomBtn" class="secondary-button">Leave Room</button>
            </div>
            <div id="status">Ready to chat</div>
            <div class="input-indicator">
                <div class="input-dot" id="inputDot"></div>
                <span>Input Level</span>
            </div>
            <div class="volume-meter">
                <div class="volume-level" id="volumeLevel"></div>
            </div>
            <div class="controls">
                <button id="recordButton">Start Chat</button>
                <button id="stopButton" disabled>Stop Chat</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const authContainer = document.getElementById('authContainer');
        const chatContainer = document.getElementById('chatContainer');
        const createRoomForm = document.getElementById('createRoomForm');
        const joinRoomForm = document.getElementById('joinRoomForm');
        const authError = document.getElementById('authError');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const createRoomSubmit = document.getElementById('createRoomSubmit');
        const joinRoomSubmit = document.getElementById('joinRoomSubmit');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const statusElement = document.getElementById('status');
        const volumeLevel = document.getElementById('volumeLevel');
        const inputDot = document.getElementById('inputDot');
        const leaveRoomBtn = document.getElementById('leaveRoomBtn');
        const participantCount = document.getElementById('participantCount');

        let audioContext;
        let sourceNode;
        let processorNode;
        let analyserNode;
        let isRecording = false;
        let lastProcessTime = 0;
        let authenticated = false;

        // Buffer for playback
        let playbackQueue = [];
        let isPlaying = false;
        let latencyHistory = [];
        const MAX_LATENCY_HISTORY = 100;

        // Authentication handlers
        createRoomBtn.onclick = () => {
            createRoomForm.style.display = 'block';
            joinRoomForm.style.display = 'none';
        };

        joinRoomBtn.onclick = () => {
            joinRoomForm.style.display = 'block';
            createRoomForm.style.display = 'none';
        };

        createRoomSubmit.onclick = async () => {
            const roomId = document.getElementById('newRoomId').value;
            const password = document.getElementById('newRoomPassword').value;
            
            try {
                const response = await fetch('/create_room', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `room_id=${encodeURIComponent(roomId)}&password=${encodeURIComponent(password)}`
                });
                
                const data = await response.json();
                if (data.error) {
                    authError.textContent = data.error;
                } else {
                    authenticate(roomId, password);
                }
            } catch (err) {
                authError.textContent = 'Error creating room';
            }
        };

        joinRoomSubmit.onclick = () => {
            const roomId = document.getElementById('roomId').value;
            const password = document.getElementById('roomPassword').value;
            authenticate(roomId, password);
        };

        function authenticate(roomId, password) {
            socket.emit('authenticate', { room_id: roomId, password: password });
        }

        socket.on('authentication_success', (data) => {
            authenticated = true;
            authContainer.style.display = 'none';
            chatContainer.style.display = 'block';
            updateParticipantCount(data.participant_count);
            initAudio();
        });

        socket.on('authentication_failed', (data) => {
            authError.textContent = data.message;
        });

        socket.on('participant_update', (data) => {
            updateParticipantCount(data.count);
        });

        function updateParticipantCount(count) {
            participantCount.textContent = `${count} ${count === 1 ? 'person' : 'people'} in room`;
        }

        leaveRoomBtn.onclick = () => {
            if (confirm('Are you sure you want to leave the room?')) {
                socket.emit('leave_room');
                authenticated = false;
                chatContainer.style.display = 'none';
                authContainer.style.display = 'block';
                // Reset forms
                createRoomForm.style.display = 'none';
                joinRoomForm.style.display = 'none';
                authError.textContent = '';
            }
        };

        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                sourceNode = audioContext.createMediaStreamSource(stream);
                
                // Create analyser node for volume visualization
                analyserNode = audioContext.createAnalyser();
                analyserNode.fftSize = 128; // Reduced from 256 for faster processing
                analyserNode.smoothingTimeConstant = 0.3; // Reduced smoothing for faster response
                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                // Reduced buffer size for lower latency
                processorNode = audioContext.createScriptProcessor(1024, 1, 1);

                processorNode.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    
                    const currentTime = performance.now();
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // Calculate RMS value for volume with smoothing
                    let sum = 0;
                    for (let i = 0; i < inputData.length; i++) {
                        sum += inputData[i] * inputData[i];
                    }
                    const rms = Math.sqrt(sum / inputData.length);
                    const db = 20 * Math.log10(rms);
                    
                    // Apply smoothing to the volume calculation
                    const rawVolume = Math.min(100, Math.max(0, (db + 100) * 1.5));
                    const smoothedVolume = Math.min(100, rawVolume * 0.7); // Reduce sensitivity by 30%
                    
                    // Update visual indicators
                    volumeLevel.style.width = `${smoothedVolume}%`;
                    inputDot.classList.toggle('active', rawVolume > 20); // Keep the same threshold for activation
                    
                    // Convert and send audio data
                    const int16Buffer = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        int16Buffer[i] = inputData[i] * 0x7FFF;
                    }
                    
                    // Add timestamp to track latency
                    const audioData = {
                        timestamp: currentTime,
                        data: int16Buffer.buffer
                    };
                    
                    socket.emit('voice_data', audioData);
                    
                    // Calculate processing time
                    const processTime = performance.now() - currentTime;
                    lastProcessTime = processTime;
                    
                    // Update latency history
                    latencyHistory.push(processTime);
                    if (latencyHistory.length > MAX_LATENCY_HISTORY) {
                        latencyHistory.shift();
                    }
                };

                // Optimized audio node connections
                sourceNode.connect(analyserNode);
                analyserNode.connect(processorNode);
                processorNode.connect(audioContext.destination);

                recordButton.disabled = false;
                statusElement.textContent = "Ready to chat";
            } catch (err) {
                console.error("Error in audio initialization:", err);
                statusElement.textContent = "Error: " + err.message;
            }
        }

        recordButton.onclick = () => {
            if (isRecording) return;
            isRecording = true;
            recordButton.disabled = true;
            stopButton.disabled = false;
            statusElement.textContent = "Chatting...";
            statusElement.classList.add("recording");
            
            // Resume audio context if it was suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log("AudioContext resumed");
                });
            }
        };

        stopButton.onclick = () => {
            if (!isRecording) return;
            isRecording = false;
            recordButton.disabled = false;
            stopButton.disabled = true;
            statusElement.textContent = "Ready to chat";
            statusElement.classList.remove("recording");
            volumeLevel.style.width = "0%";
            inputDot.classList.remove('active');
        };

        // Play received audio with latency compensation
        socket.on('voice_data', (audioData) => {
            const receiveTime = performance.now();
            const latency = receiveTime - audioData.timestamp;
            
            // Add to playback queue with timestamp
            playbackQueue.push({
                data: audioData.data,
                timestamp: audioData.timestamp
            });
            
            if (!isPlaying) playFromQueue();
        });

        function playFromQueue() {
            if (playbackQueue.length === 0) {
                isPlaying = false;
                return;
            }
            
            isPlaying = true;
            const audioItem = playbackQueue.shift();
            const currentTime = performance.now();
            const latency = currentTime - audioItem.timestamp;
            
            // Skip if too much latency
            if (latency > 500) { // Skip if more than 500ms late
                playFromQueue();
                return;
            }
            
            const arrayBuffer = audioItem.data;
            const int16Array = new Int16Array(arrayBuffer);
            const float32Array = new Float32Array(int16Array.length);
            
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 0x7FFF;
            }
            
            const audioBuffer = audioContext.createBuffer(1, float32Array.length, audioContext.sampleRate);
            audioBuffer.copyToChannel(float32Array, 0);
            
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.onended = playFromQueue;
            source.start();
        }

        window.onload = initAudio;
    </script>
</body>
</html>